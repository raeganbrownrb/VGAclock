25 =>"00000000000000000000000000111111",26 =>"00000000000000000000000000111111",27 =>"00000000000000000000000000111111",28 =>"00000000000000000000000000111111",29=>"00000000000000000000000000111111",30 =>"00000000000000000000000000111111",31 =>"00000000000000000000000000000000"); constant A :values :=(0 => "11111111111111111111111111111111",1 =>"11111111111111111111111111111111", 2 =>"11111111111110000001111111111111",3 =>"11111111111100000000111111111111",4 =>"11111111111000000000011111111111",5 =>"11111111110000000000001111111111",6 =>"11111111100000000000000111111111",7 =>"11111111000000000000000011111111",8 =>"11111100000000000000000000111111",9 =>"11111100000000000000000000111111",10 =>"11111100000000000000000000011111",11 =>"11111111111111111111111111111111",12 =>"11111111111111111111111111111111",13 =>"11111111111111111111111111111111",14 =>"11111111111111111111111111111111",15 =>"11111111000000000000000011111111",16 => "11111111000000000000000011111111",17 =>"11111111000000000000000011111111", 18 =>"11111111000000000000000011111111",19 =>"11111111000000000000000011111111",20 =>"11111111000000000000000011111111",21 =>"11111111000000000000000011111111",22 =>"11111111000000000000000011111111",23 =>"11111111000000000000000011111111",24 =>"11111111000000000000000011111111",25 =>"00000000000000000000000000000000",26 =>"00000000000000000000000000000000",27 =>"00000000000000000000000000000000",28 =>"00000000000000000000000000000000",29=>"00000000000000000000000000000000",30 =>"00000000000000000000000000000000",31 =>"00000000000000000000000000000000"); constant P :values :=(0 => "00000000000000000000000000000000",1 =>"11111111111111111111111111111111", 2 =>"11111111111111111111111111111111",3 =>"11111111111111111111111111111111",4 =>"11111111111111111111111111111111",5 =>"11111111111111111111111111111111",6 =>"11111111111111111111111111111111",7 =>"11111100000000000000000000111111",8 =>"11111100000000000000000000111111",9 =>"11111100000000000000000000111111",
10 =>"11111100000000000000000000111111",11 =>"11111100000000000000000000111111",12 =>"11111100000000000000000000111111",13 =>"11111111111111111111111111111111",14 =>"11111111111111111111111111111111",15 =>"11111111111111111111111111111111",16 => "11111111111111111111111111111111",17 =>"11111100000000000000000000000000", 18 =>"11111100000000000000000000000000",19 =>"11111100000000000000000000000000",20 =>"11111100000000000000000000000000",21 =>"11111100000000000000000000000000",22 =>"11111100000000000000000000000000",23 =>"11111100000000000000000000000000",24 =>"11111100000000000000000000000000",25 =>"11111100000000000000000000000000",26 =>"00000000000000000000000000000000",27 =>"00000000000000000000000000000000",28 =>"00000000000000000000000000000000",29=>"00000000000000000000000000000000",30 =>"00000000000000000000000000111111",31 =>"00000000000000000000000000000000"); signal number,number2, number3, number4,status2: values := blank;signal clkPix: std_logic;signal cntHorz, cntVert: std_logic_vector(9 downto 0);signal sncHorz, clkLine, blkHorz, sncVert, blkVert, blkDisp, clkColor: std_logic;signal cntImg: std_logic_vector(6 downto 0);signal cntColor: std_logic_vector(2 downto 0);signal upper, left, lower, right: std_logic_vector(11 downto0);signal upper2, left2, lower2, right2: std_logic_vector(11 downto 0);signal counter1, counter2 , counter3, counter4,counter5, counter6, counter8, counter9: integer;signal colors : std_logic_vector(2 downto 0);Begin--instantiate the origin of the numbersleft2 <= X"172";right2 <= X"192";lower2 <= X"0E8";upper2 <= X"0C8";process ( data1)begin--assigns each digit to a constraint for each data inputcase data1 iswhen "0000" =>number <= zero;when "0001" =>number <= one;
when "0010"=>number <= two;when "0011" =>number <= three;when "0100" => number <= four;when "0101" => number <= five;when "0110" =>number <= six;when "0111" =>number <= seven;when "1000" =>number <= eight;when "1001" =>number <= nine;when others =>number <= blank;end case;end process;process ( data2)begincase data2 iswhen "0000" =>number2 <= zero;when "0001" =>number2 <= one;when "0010" =>number2 <= two;when "0011" =>number2 <= three;when "0100" => number2 <= four;when "0101" => number2 <= five;when "0110" =>number2 <= six;when "0111" =>number2 <= seven;when "1000" =>number2 <= eight;when "1001" =>number2 <= nine;when others =>number2 <= blank;end case;end process;process(data3)
begincase data3 iswhen "0000" =>number3 <= zero;when "0001" =>number3 <= one;when "0010" =>number3 <= two;when "0011" =>number3 <= three;when "0100" => number3 <= four;when "0101" => number3 <= five;when "0110" =>number3 <= six;when "0111" =>number3 <= seven;when "1000" =>number3 <= eight;when "1001" =>number3 <= nine;when others =>number3 <= blank;end case;end process;process(data4)begincase data4 iswhen "0000" =>number4 <= zero;when "0001" =>number4 <= one;when "0010" =>number4 <= two;when "0011" =>number4 <= three;when "0100" => number4 <= four;when "0101" => number4 <= five;when "0110" =>number4<= six;when "0111" =>number4 <= seven;when "1000" =>number4 <= eight;when "1001" =>number4 <= nine;
when others =>number4 <= blank;end case;end process;process(PA)begincase PA iswhen "00" =>status2 <= A;colors <= "011";when "01" =>status2 <= P;colors <= "000";when "10" =>if inputs = '0' thenstatus2 <= A;colors <= "110";elsif inputs = '1' thenstatus2 <= P;colors <= "110";end if;when "11" =>status2 <= five;colors <= "100";when others =>status2 <= blank;end case;end process;--------------------------------------------------------------------------VGA Controller Test--------------------------------------------------------------------------Divide the D2XL oscillator down to form the pixel clock--that is the basis for all of the other timing.process (mclk)beginif mclk = '1' and mclk'Event thenclkPix <= not clkPix;end if;end process;--Generate the horizontal timing.process (clkPix)beginif clkPix = '1' and clkPix'Event then
if cntHorz = "0001011101" thencntHorz <= cntHorz + 1;sncHorz <= '1';elsif cntHorz = "0010001100" thencntHorz <= cntHorz + 1;blkHorz <= '0';elsif cntHorz = "1100001100" thencntHorz <= cntHorz + 1;blkHorz <= '1';elsif cntHorz = "1100011010" thencntHorz <= "0000000000";clkLine <= '1';sncHorz <= '0';elsecntHorz <= cntHorz + 1;clkLine <= '0';end if;if (cntHorz < right2 and cntHorz > left2) thencounter1 <= counter1 + 1;elsecounter1 <= 0;end if;--counter created for each digit elementif (cntHorz < (right2+X"02A") and cntHorz > (left2+X"02A")) thencounter3 <= counter3 + 1;elsecounter3 <= 0;end if;if (cntHorz < (right2+X"064") and cntHorz > (left2+X"064")) thencounter4 <= counter4 + 1;elsecounter4 <= 0;end if;if (cntHorz < (right2+X"08E") and cntHorz > (left2+X"08E")) thencounter5 <= counter5 + 1;elsecounter5 <= 0;end if;if (cntHorz < (right2+X"04A") and cntHorz > (left2+X"04A")) thencounter6 <= counter6 + 1;elsecounter6 <= 0;    end if;if (cntHorz < (right2+X"0DA") and cntHorz > (left2+X"0DA")) thencounter9 <= counter9 + 1;else
counter9 <= 0;    end if;end if;end process;--Generate the vertical timing.process (clkLine)beginif clkLine = '1' and clkLine'Event thenif cntVert = "0000000001" thencntVert <= cntVert + 1;sncVert <= '1';--datain <= data4;elsif cntVert = "0000011010" thencntVert <= cntVert + 1;blkVert <= '0';elsif cntVert = "0111111010" thencntVert <= cntVert + 1;blkVert <= '1';elsif cntVert = "1000001100" thencntVert <= "0000000000";sncVert <= '0';elsecntVert<= cntVert + 1;end if;if (cntVert > upper2 and cntVert < lower2) thencounter2 <= counter2 + 1;elsecounter2 <= 0;end if;if (cntVert > (upper2+X"02A") and cntVert < (lower2+X"02A")) thencounter8 <= counter8 + 1;elsecounter8 <= 0;end if;end if;end process;--Divide the active portion of a scan line into 8 regions.--This counts up to 79 and then resets. Each time it
--resets, it generates a pulse on clkColor.process (clkPix, blkDisp)beginif clkPix = '1' and clkPix'Event thenif blkDisp = '1' thencntImg <= "0000000";elseif cntImg = "1001111" thencntImg <= "0000000";clkColor <= '1';elsecntImg <= cntImg + 1;clkColor <= '0';end if;end if;end if;end process;--when statement for actual display of elements and when to activate them on the --screenblkDisp <= blkVert or blkHorz;cntColor <= "111" when cntHorz < right2 and cntHorz > left2and cntVert < lower2 and cntVert > upper2 and (number4(counter2)(counter1) ='1') else "111" when cntHorz < (right2+X"02A")and cntHorz > (left2+X"02A") and cntVert < lower2 and cntVert > upper2 and  (number3(counter2)(counter3) ='1') else "111" when cntHorz < (right2+X"04A")and cntHorz > (left2+X"04A") and cntVert < lower2 and cntVert > upper2 and  (colon(counter2)(counter6) ='1') else "111" when cntHorz < (right2+X"064")and cntHorz > (left2+X"064") and cntVert < lower2 and cntVert > upper2 and  (number2(counter2)(counter4) ='1') else "111" when cntHorz < (right2+X"08E")and cntHorz > (left2+X"08E") and cntVert < lower2 and cntVert > upper2 and  (number(counter2)(counter5) ='1') else "111" when cntHorz < (right2+X"0DA") and cntHorz > (left2+X"0DA") and  cntVert > (upper2+X"02A") and cntVert < (lower2+X"02A") and (status2(counter8)(counter9) = '1')else colors; --and  else "111";vs  <= sncVert;hs  <= sncHorz;blu <= cntColor(0) and (not blkDisp);grn <= cntColor(1) and (not blkDisp);red <= cntColor(2) and (not blkDisp);end Behavioral
